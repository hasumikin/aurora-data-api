#!/usr/bin/env ruby

require "aurora-data-api/version"
require "thor"

class Date
end

module AuroraDataApi
  class Error < StandardError; end

  class Schema
    CREATE_TABLE = []
    ALTER_TABLE = []
  end

  class Model
    SCHEMA = {literal_id: :id}

    def self.literal_id(lit)
      SCHEMA[:literal_id] = lit
    end

    def self.table(name)
      SCHEMA[:table_name] = name
    end

    def self.schema(&block)
      converter = Converter.new(SCHEMA, self)
      converter.head
      converter.instance_eval(&block)
      converter.tail
      Schema::CREATE_TABLE << converter.create_table
      Schema::ALTER_TABLE << converter.alter_table
    end
  end

  class Converter
    TYPES = {
      ::Date => "date",
      ::Time => "timestamp with time zone",
      ::String => "text",
      ::Integer => "bigint",
      ::Float => "double precision"
    }

    def initialize(schema, klass)
      @table_name = schema[:table_name] || "#{klass.name.downcase}s"
      @literal_id = schema[:literal_id]
      @create_table = []
      @alter_table = []
    end

    attr_reader :create_table, :alter_table

    def head
      @create_table << %/CREATE TABLE "#{@table_name}" (/
      @create_table << %(  "#{@literal_id}" bigint NOT NULL GENERATED ALWAYS AS IDENTITY,)
    end

    def tail
      @create_table << %(  "created_at" #{TYPES[Time]} NOT NULL,)
      @create_table << %(  "updated_at" #{TYPES[Time]} NOT NULL,)
      @create_table << %/  PRIMARY KEY ("#{@literal_id}")/
      @create_table << %/);\n/
    end

    def col(name, type, **params)
      line = "  "
      case type
      when Symbol
        col_name = "#{name}_#{@literal_id}"
        line << %("#{col_name}" )
        line << TYPES[Integer]
        @alter_table << %/ALTER TABLE ONLY "#{@table_name}" ADD CONSTRAINT "#{@table_name}_#{col_name}_fkey" FOREIGN KEY ("#{col_name}") REFERENCES "#{params[:table_name]}" ("#{@literal_id}");/
      else
        line << %("#{name}" )
        line << TYPES[type]
      end
      params.each do |k, v|
        case k
        when :null
          line << " NOT NULL" unless v
        when :default
          line << " DEFAULT "
          line << case v
          when String, Symbol
            "'#{v}'"
          else
            v.to_s
          end
        when :unique
          line << " UNIQUE" if v
        end
      end
      line << ","
      @create_table << line
    end
  end

  class Tool < Thor
    DEFAULT_MODELS_DIR = "app/models"
    DEFAULT_OUTPUT_PATH = "db/schema.sql"

    desc "version", "Print version"
    def version
      puts "aurora-data-api v#{AuroraDataApi::VERSION}"
    end

    desc "export", "Overwrite #{DEFAULT_OUTPUT_PATH} by aggregating #{DEFAULT_MODELS_DIR}/*.rb"
    option :models, aliases: :m, default: DEFAULT_MODELS_DIR
    option :output, aliases: :o, default: DEFAULT_OUTPUT_PATH
    def export
      models_dir = options[:models]
      output_path = options[:output]
      Dir.glob("#{models_dir}/*.rb").each do |rb|
        load rb
      end
      if Schema::CREATE_TABLE.empty? && Schema::ALTER_TABLE.empty?
        puts "Nothing to be exported."
        exit
      end
      overwrite = false
      if File.exist? output_path
        print "#{output_path} exists. Overwrite? [Y/n]: "
        answer = $stdin.gets.chomp
        if %w[Y y yes].include?(answer.chomp)
          overwrite = true
        else
          puts "Abort."
          exit
        end
      else
        overwrite = true
      end
      if overwrite
        File.open output_path, "w" do |f|
          f.write <<~COMMENT
            /*
             * This file was automatically genarated by the command:
             *   aurora-data-api export --models #{models_dir} --output #{output_path}
             *
             * Genarated at #{Time.now}
             *
             * https://github.com/hasumikin/aurora-data-api
             */\n
          COMMENT
          f.write Schema::CREATE_TABLE.flatten.join("\n")
          f.write "\n"
          f.write Schema::ALTER_TABLE.flatten.join("\n")
        end
      end
    end
  end
end

AuroraDataApi::Tool.start
